const fs = require('fs');

// ==============================================================================
// 1. SETUP & DATA LOADING
// ==============================================================================
// Load the raw data file that was generated by the previous fetch script.
// This ensures we are analyzing the exact dataset provided in the submission.
console.log("ðŸ“– Reading JSON file...\n");
const data = JSON.parse(fs.readFileSync('dexpay_contract_calls_2025.json', 'utf8'));

// We use a 'Set' data structure because it automatically handles deduplication.
// Even if a user transacts 50 times, they will only be counted ONCE here.
const uniqueWallets = new Set();

// Define the Contract's EVM address.
// CRITICAL: We must exclude this address from the count so we don't count 
// the contract as a "user" of itself.
const CONTRACT_ADDRESS = "0x00000000000000000000000000000000008f5690".toLowerCase();

// ==============================================================================
// 2. ANALYZE INBOUND TRAFFIC (Users -> Contract)
// ==============================================================================
console.log("ðŸ” Analyzing contract results (calls TO contract)...");

// Loop through 'contractResults'. On Hedera, this list represents users 
// who initiated a call to the smart contract (e.g. Depositing funds).
data.contractResults.forEach(result => {
  // The 'from' field identifies the caller (The User)
  if (result.from) {
    const from = result.from.toLowerCase();
    
    // FILTERING LOGIC:
    // Only add this address if it is NOT the contract itself.
    if (from !== CONTRACT_ADDRESS) {
      uniqueWallets.add(result.from); // Keep original case for display
    }
  }
});

console.log(`  Found ${uniqueWallets.size} unique wallets calling the contract\n`);

// ==============================================================================
// 3. ANALYZE OUTBOUND TRAFFIC (Contract -> Users)
// ==============================================================================
console.log("ðŸ” Analyzing transactions (FROM contract to users)...");

// Loop through 'transactions'. This represents settlement activity where
// the contract sends funds back to users.
let additionalWallets = 0;
data.transactions.forEach(tx => {
  
  // A. Check HBAR Transfers
  // Look at the list of accounts involved in value transfer
  if (tx.transfers) {
    tx.transfers.forEach(transfer => {
      if (transfer.account) {
        const account = transfer.account.toLowerCase();
        
        // FILTERING LOGIC:
        // We exclude the Contract's EVM address AND its Hedera ID (0.0.x).
        // Any other address receiving funds is a Unique User.
        if (account !== CONTRACT_ADDRESS && account !== `0.0.${data.metadata.contractId.split('.')[2]}`) {
          const beforeSize = uniqueWallets.size;
          
          // Add to our Unique Set
          uniqueWallets.add(transfer.account);
          
          // logic to track how many *new* users we found in this step
          if (uniqueWallets.size > beforeSize) {
            additionalWallets++;
          }
        }
      }
    });
  }
  
  // B. Check Token Transfers (e.g. USDC)
  // Essential for DexPay as we handle stablecoin settlements.
  if (tx.token_transfers) {
    tx.token_transfers.forEach(transfer => {
      if (transfer.account) {
        const account = transfer.account.toLowerCase();
        
        // Apply same filtering logic (User != Contract)
        if (account !== CONTRACT_ADDRESS && account !== `0.0.${data.metadata.contractId.split('.')[2]}`) {
          const beforeSize = uniqueWallets.size;
          uniqueWallets.add(transfer.account);
          if (uniqueWallets.size > beforeSize) {
            additionalWallets++;
          }
        }
      }
    });
  }
});

console.log(`  Found ${additionalWallets} additional unique wallets receiving from contract\n`);

// ==============================================================================
// 4. GENERATE REPORT
// ==============================================================================
console.log("=".repeat(60));
console.log("ðŸ“Š FINAL RESULTS");
console.log("=".repeat(60));
// Print the final, deduplicated count of real users
console.log(`ðŸ‘¥ Total Unique Wallets: ${uniqueWallets.size}`);
console.log(`ðŸ“¥ Contract Calls: ${data.metadata.totalContractResults}`);
console.log(`ðŸ“¤ Transactions: ${data.metadata.totalTransactions}`);
console.log(`ðŸ“… Period: ${data.metadata.period}`);
console.log("=".repeat(60));

// Create a clean JSON object with the verified list
const walletsList = {
  totalUniqueWallets: uniqueWallets.size,
  period: data.metadata.period,
  contractId: data.metadata.contractId,
  wallets: Array.from(uniqueWallets).sort() // Sort alphabetically for easier manual check
};

// Save the verified list to disk
fs.writeFileSync('unique_wallets_2025.json', JSON.stringify(walletsList, null, 2));
console.log("\nðŸ’¾ Saved unique wallets list to: unique_wallets_2025.json");

// Display a sample to the console so the reviewer can see the format immediately
console.log("\nðŸ“‹ Sample wallets (first 10):");
Array.from(uniqueWallets).slice(0, 10).forEach((wallet, i) => {
  console.log(`  ${i + 1}. ${wallet}`);
});

if (uniqueWallets.size > 10) {
  console.log(`  ... and ${uniqueWallets.size - 10} more`);
}